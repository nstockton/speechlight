{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"license/","text":"The MIT License (MIT) \u00b6 Copyright \u00a9 2025 Nick Stockton Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#the-mit-license-mit","text":"Copyright \u00a9 2025 Nick Stockton Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"api/","text":"Speechlight API \u00b6 Automatically generated API reference. Speechlight \u00b6 Base Speech Darwin Speech Dummy Speech Module Windows Speech","title":"API Index"},{"location":"api/#speechlight-api","text":"Automatically generated API reference.","title":"Speechlight API"},{"location":"api/#speechlight","text":"Base Speech Darwin Speech Dummy Speech Module Windows Speech","title":"Speechlight"},{"location":"api/base/","text":"Module speechlight.base \u00b6 Contains the base class. Class BaseSpeech( ABC ) \u00b6 The base interface that Speech inherits from. Source code in speechlight/base.py class BaseSpeech ( ABC ): \"\"\"The base interface that Speech inherits from.\"\"\" @abstractmethod def braille ( self , text : str ) -> None : \"\"\" Brailles text. Args: text: The text to be brailled. \"\"\" @abstractmethod def output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speaks and brailles text. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\" @abstractmethod def say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speaks text. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" @abstractmethod def silence ( self ) -> None : \"\"\"Cancels speech and flushes the speech buffer.\"\"\" @abstractmethod def speaking ( self ) -> bool : \"\"\" Determines if text is currently being spoken. Returns: True if text is currently being spoken, False otherwise. \"\"\" Method braille ( self , text ) \u00b6 Brailles text. Parameters: Name Type Description Default text str The text to be brailled. required Source code in speechlight/base.py @abstractmethod def braille ( self , text : str ) -> None : \"\"\" Brailles text. Args: text: The text to be brailled. \"\"\" Method output ( self , text , * , interrupt = False ) \u00b6 Speaks and brailles text. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/base.py @abstractmethod def output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speaks and brailles text. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\" Method say ( self , text , * , interrupt = False ) \u00b6 Speaks text. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/base.py @abstractmethod def say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speaks text. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" Method silence ( self ) \u00b6 Cancels speech and flushes the speech buffer. Source code in speechlight/base.py @abstractmethod def silence ( self ) -> None : \"\"\"Cancels speech and flushes the speech buffer.\"\"\" Method speaking ( self ) \u00b6 Determines if text is currently being spoken. Returns: Type Description bool True if text is currently being spoken, False otherwise. Source code in speechlight/base.py @abstractmethod def speaking ( self ) -> bool : \"\"\" Determines if text is currently being spoken. Returns: True if text is currently being spoken, False otherwise. \"\"\"","title":"base.py"},{"location":"api/base/#speechlight.base","text":"Contains the base class.","title":"base"},{"location":"api/base/#speechlight.base.BaseSpeech","text":"The base interface that Speech inherits from. Source code in speechlight/base.py class BaseSpeech ( ABC ): \"\"\"The base interface that Speech inherits from.\"\"\" @abstractmethod def braille ( self , text : str ) -> None : \"\"\" Brailles text. Args: text: The text to be brailled. \"\"\" @abstractmethod def output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speaks and brailles text. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\" @abstractmethod def say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speaks text. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" @abstractmethod def silence ( self ) -> None : \"\"\"Cancels speech and flushes the speech buffer.\"\"\" @abstractmethod def speaking ( self ) -> bool : \"\"\" Determines if text is currently being spoken. Returns: True if text is currently being spoken, False otherwise. \"\"\"","title":"BaseSpeech"},{"location":"api/base/#speechlight.base.BaseSpeech.braille","text":"Brailles text. Parameters: Name Type Description Default text str The text to be brailled. required Source code in speechlight/base.py @abstractmethod def braille ( self , text : str ) -> None : \"\"\" Brailles text. Args: text: The text to be brailled. \"\"\"","title":"braille()"},{"location":"api/base/#speechlight.base.BaseSpeech.output","text":"Speaks and brailles text. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/base.py @abstractmethod def output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speaks and brailles text. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\"","title":"output()"},{"location":"api/base/#speechlight.base.BaseSpeech.say","text":"Speaks text. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/base.py @abstractmethod def say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speaks text. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\"","title":"say()"},{"location":"api/base/#speechlight.base.BaseSpeech.silence","text":"Cancels speech and flushes the speech buffer. Source code in speechlight/base.py @abstractmethod def silence ( self ) -> None : \"\"\"Cancels speech and flushes the speech buffer.\"\"\"","title":"silence()"},{"location":"api/base/#speechlight.base.BaseSpeech.speaking","text":"Determines if text is currently being spoken. Returns: Type Description bool True if text is currently being spoken, False otherwise. Source code in speechlight/base.py @abstractmethod def speaking ( self ) -> bool : \"\"\" Determines if text is currently being spoken. Returns: True if text is currently being spoken, False otherwise. \"\"\"","title":"speaking()"},{"location":"api/darwin/","text":"Module speechlight.darwin \u00b6 Darwin speech. Class Speech( BaseSpeech ) \u00b6 Implements Speech for Darwin. Source code in speechlight/darwin.py class Speech ( BaseSpeech ): \"\"\"Implements Speech for Darwin.\"\"\" _darwin : Optional [ Any ] = None def __init__ ( self ) -> None : # pragma: no cover \"\"\"Defines the constructor.\"\"\" # Allocate and initialize the default TTS. if sys . platform == \"darwin\" : self . _darwin = NSSpeechSynthesizer . alloc () . init () def braille ( self , text : str ) -> None : # NOQA: D102 pass def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 self . say ( text , interrupt = interrupt ) self . braille ( text ) def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . _darwin is not None : if interrupt : self . silence () self . _darwin . startSpeakingString_ ( text ) def silence ( self ) -> None : # NOQA: D102 if self . _darwin is not None : self . _darwin . stopSpeaking () def speaking ( self ) -> bool : # NOQA: D102 status = False if self . _darwin is not None : status = bool ( self . _darwin . isSpeaking ()) return status Method __init__ ( self ) special \u00b6 Defines the constructor. Source code in speechlight/darwin.py def __init__ ( self ) -> None : # pragma: no cover \"\"\"Defines the constructor.\"\"\" # Allocate and initialize the default TTS. if sys . platform == \"darwin\" : self . _darwin = NSSpeechSynthesizer . alloc () . init () Method braille ( self , text ) \u00b6 Brailles text. Parameters: Name Type Description Default text str The text to be brailled. required Source code in speechlight/darwin.py def braille ( self , text : str ) -> None : # NOQA: D102 pass Method output ( self , text , * , interrupt = False ) \u00b6 Speaks and brailles text. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/darwin.py def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 self . say ( text , interrupt = interrupt ) self . braille ( text ) Method say ( self , text , * , interrupt = False ) \u00b6 Speaks text. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/darwin.py def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . _darwin is not None : if interrupt : self . silence () self . _darwin . startSpeakingString_ ( text ) Method silence ( self ) \u00b6 Cancels speech and flushes the speech buffer. Source code in speechlight/darwin.py def silence ( self ) -> None : # NOQA: D102 if self . _darwin is not None : self . _darwin . stopSpeaking () Method speaking ( self ) \u00b6 Determines if text is currently being spoken. Returns: Type Description bool True if text is currently being spoken, False otherwise. Source code in speechlight/darwin.py def speaking ( self ) -> bool : # NOQA: D102 status = False if self . _darwin is not None : status = bool ( self . _darwin . isSpeaking ()) return status","title":"darwin.py"},{"location":"api/darwin/#speechlight.darwin","text":"Darwin speech.","title":"darwin"},{"location":"api/darwin/#speechlight.darwin.Speech","text":"Implements Speech for Darwin. Source code in speechlight/darwin.py class Speech ( BaseSpeech ): \"\"\"Implements Speech for Darwin.\"\"\" _darwin : Optional [ Any ] = None def __init__ ( self ) -> None : # pragma: no cover \"\"\"Defines the constructor.\"\"\" # Allocate and initialize the default TTS. if sys . platform == \"darwin\" : self . _darwin = NSSpeechSynthesizer . alloc () . init () def braille ( self , text : str ) -> None : # NOQA: D102 pass def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 self . say ( text , interrupt = interrupt ) self . braille ( text ) def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . _darwin is not None : if interrupt : self . silence () self . _darwin . startSpeakingString_ ( text ) def silence ( self ) -> None : # NOQA: D102 if self . _darwin is not None : self . _darwin . stopSpeaking () def speaking ( self ) -> bool : # NOQA: D102 status = False if self . _darwin is not None : status = bool ( self . _darwin . isSpeaking ()) return status","title":"Speech"},{"location":"api/darwin/#speechlight.darwin.Speech.__init__","text":"Defines the constructor. Source code in speechlight/darwin.py def __init__ ( self ) -> None : # pragma: no cover \"\"\"Defines the constructor.\"\"\" # Allocate and initialize the default TTS. if sys . platform == \"darwin\" : self . _darwin = NSSpeechSynthesizer . alloc () . init ()","title":"__init__()"},{"location":"api/darwin/#speechlight.darwin.Speech.braille","text":"Brailles text. Parameters: Name Type Description Default text str The text to be brailled. required Source code in speechlight/darwin.py def braille ( self , text : str ) -> None : # NOQA: D102 pass","title":"braille()"},{"location":"api/darwin/#speechlight.darwin.Speech.output","text":"Speaks and brailles text. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/darwin.py def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 self . say ( text , interrupt = interrupt ) self . braille ( text )","title":"output()"},{"location":"api/darwin/#speechlight.darwin.Speech.say","text":"Speaks text. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/darwin.py def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . _darwin is not None : if interrupt : self . silence () self . _darwin . startSpeakingString_ ( text )","title":"say()"},{"location":"api/darwin/#speechlight.darwin.Speech.silence","text":"Cancels speech and flushes the speech buffer. Source code in speechlight/darwin.py def silence ( self ) -> None : # NOQA: D102 if self . _darwin is not None : self . _darwin . stopSpeaking ()","title":"silence()"},{"location":"api/darwin/#speechlight.darwin.Speech.speaking","text":"Determines if text is currently being spoken. Returns: Type Description bool True if text is currently being spoken, False otherwise. Source code in speechlight/darwin.py def speaking ( self ) -> bool : # NOQA: D102 status = False if self . _darwin is not None : status = bool ( self . _darwin . isSpeaking ()) return status","title":"speaking()"},{"location":"api/dummy/","text":"Module speechlight.dummy \u00b6 Dummy speech. Class Speech( BaseSpeech ) \u00b6 Implements Speech for the dummy platform. Source code in speechlight/dummy.py class Speech ( BaseSpeech ): \"\"\"Implements Speech for the dummy platform.\"\"\" def braille ( self , text : str ) -> None : # NOQA: D102 pass def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 self . say ( text , interrupt = interrupt ) self . braille ( text ) def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if interrupt : self . silence () def silence ( self ) -> None : # NOQA: D102 pass def speaking ( self ) -> bool : # NOQA: D102, PLR6301 return False Method braille ( self , text ) \u00b6 Brailles text. Parameters: Name Type Description Default text str The text to be brailled. required Source code in speechlight/dummy.py def braille ( self , text : str ) -> None : # NOQA: D102 pass Method output ( self , text , * , interrupt = False ) \u00b6 Speaks and brailles text. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/dummy.py def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 self . say ( text , interrupt = interrupt ) self . braille ( text ) Method say ( self , text , * , interrupt = False ) \u00b6 Speaks text. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/dummy.py def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if interrupt : self . silence () Method silence ( self ) \u00b6 Cancels speech and flushes the speech buffer. Source code in speechlight/dummy.py def silence ( self ) -> None : # NOQA: D102 pass Method speaking ( self ) \u00b6 Determines if text is currently being spoken. Returns: Type Description bool True if text is currently being spoken, False otherwise. Source code in speechlight/dummy.py def speaking ( self ) -> bool : # NOQA: D102, PLR6301 return False","title":"dummy.py"},{"location":"api/dummy/#speechlight.dummy","text":"Dummy speech.","title":"dummy"},{"location":"api/dummy/#speechlight.dummy.Speech","text":"Implements Speech for the dummy platform. Source code in speechlight/dummy.py class Speech ( BaseSpeech ): \"\"\"Implements Speech for the dummy platform.\"\"\" def braille ( self , text : str ) -> None : # NOQA: D102 pass def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 self . say ( text , interrupt = interrupt ) self . braille ( text ) def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if interrupt : self . silence () def silence ( self ) -> None : # NOQA: D102 pass def speaking ( self ) -> bool : # NOQA: D102, PLR6301 return False","title":"Speech"},{"location":"api/dummy/#speechlight.dummy.Speech.braille","text":"Brailles text. Parameters: Name Type Description Default text str The text to be brailled. required Source code in speechlight/dummy.py def braille ( self , text : str ) -> None : # NOQA: D102 pass","title":"braille()"},{"location":"api/dummy/#speechlight.dummy.Speech.output","text":"Speaks and brailles text. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/dummy.py def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 self . say ( text , interrupt = interrupt ) self . braille ( text )","title":"output()"},{"location":"api/dummy/#speechlight.dummy.Speech.say","text":"Speaks text. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/dummy.py def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if interrupt : self . silence ()","title":"say()"},{"location":"api/dummy/#speechlight.dummy.Speech.silence","text":"Cancels speech and flushes the speech buffer. Source code in speechlight/dummy.py def silence ( self ) -> None : # NOQA: D102 pass","title":"silence()"},{"location":"api/dummy/#speechlight.dummy.Speech.speaking","text":"Determines if text is currently being spoken. Returns: Type Description bool True if text is currently being spoken, False otherwise. Source code in speechlight/dummy.py def speaking ( self ) -> bool : # NOQA: D102, PLR6301 return False","title":"speaking()"},{"location":"api/windows/","text":"Module speechlight.windows \u00b6 Windows speech. Class Speech( BaseSpeech ) \u00b6 Implements Speech for Windows. Source code in speechlight/windows.py class Speech ( BaseSpeech ): # NOQA: PLR0904 \"\"\"Implements Speech for Windows.\"\"\" _find_window : Optional [ Any ] = None _nvda : Optional [ Any ] = None _sa : Optional [ Any ] = None _sapi : Optional [ Any ] = None _jfw : Optional [ Any ] = None def __init__ ( self ) -> None : # pragma: no cover \"\"\"Defines the constructor.\"\"\" if sys . platform == \"win32\" : self . _find_window : ctypes . _NamedFuncPointer = ctypes . WinDLL ( \"user32\" ) . FindWindowW self . _find_window . argtypes = [ ctypes . c_wchar_p , ctypes . c_wchar_p ] self . _find_window . restype = ctypes . c_void_p arch : str = \"32\" if SYSTEM_ARCHITECTURE == \"32bit\" else \"64\" self . _nvda : ctypes . WinDLL = ctypes . windll . LoadLibrary ( str ( LIB_DIRECTORY / f \"nvdaControllerClient { arch } .dll\" ) ) self . _sa : ctypes . WinDLL = ctypes . windll . LoadLibrary ( str ( LIB_DIRECTORY / f \"SAAPI { arch } .dll\" )) self . _nvda . nvdaController_brailleMessage . argtypes = ( ctypes . c_wchar_p ,) self . _nvda . nvdaController_speakText . argtypes = ( ctypes . c_wchar_p ,) self . _sa . SA_BrlShowTextW . argtypes = ( ctypes . c_wchar_p ,) self . _sa . SA_SayW . argtypes = ( ctypes . c_wchar_p ,) @property def sapi ( self ) -> Any : # type: ignore[misc] # pragma: no cover \"\"\"The SAPI COM object.\"\"\" self . _sapi = dispatch ( \"SAPI.SpVoice\" ) return self . _sapi @property def jfw ( self ) -> Any : # type: ignore[misc] # pragma: no cover \"\"\"The JFW COM object.\"\"\" self . _jfw = dispatch ( \"FreedomSci.JawsApi\" ) return self . _jfw def jfw_braille ( self , text : str ) -> None : \"\"\" Brailles text using JFW. Args: text: The text to braille. \"\"\" self . jfw_output ( text , braille = True ) def jfw_output ( self , text : str , * , braille : bool = False , speak : bool = False , interrupt : bool = False , ) -> None : \"\"\" Outputs text using JFW. Args: text: The output text. braille: Output text in braille. speak: Output text using speech. interrupt: True if the speech should be silenced before speaking. \"\"\" jfw = self . jfw if jfw is not None : if speak : jfw . SayString ( text , int ( bool ( interrupt ))) if braille : jfw . RunFunction ( 'BrailleString(\" {text} \")' . format ( text = text . replace ( '\"' , \"'\" ))) def jfw_running ( self ) -> bool : \"\"\" Determines if JFW is running. Returns: True if JFW is running, False otherwise. \"\"\" status : bool = False if self . _find_window is not None : status = bool ( self . _find_window ( \"JFWUI2\" , None )) return status def jfw_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using JFW. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" self . jfw_output ( text , speak = True , interrupt = interrupt ) def jfw_silence ( self ) -> None : \"\"\"Cancels JFW speech and flushes the speech buffer.\"\"\" jfw = self . jfw if jfw is not None : jfw . StopSpeech () def nvda_braille ( self , text : str ) -> None : \"\"\" Brailles text using NVDA. Args: text: The text to braille. \"\"\" if self . _nvda is not None : self . _nvda . nvdaController_brailleMessage ( text ) def nvda_output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Outputs text using NVDA. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\" self . nvda_say ( text , interrupt = interrupt ) self . nvda_braille ( text ) def nvda_running ( self ) -> bool : \"\"\" Determines if NVDA is running. Returns: True if NVDA is running, False otherwise. \"\"\" status : bool = False if self . _nvda is not None : status = bool ( self . _nvda . nvdaController_testIfRunning () == 0 ) return status def nvda_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using NVDA. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . _nvda is not None : if interrupt : self . nvda_silence () self . _nvda . nvdaController_speakText ( text ) def nvda_silence ( self ) -> None : \"\"\"Cancels NVDA speech and flushes the speech buffer.\"\"\" if self . _nvda is not None : self . _nvda . nvdaController_cancelSpeech () def sa_braille ( self , text : str ) -> None : \"\"\" Brailles text using System Access. Args: text: The text to braille. \"\"\" if self . _sa is not None : self . _sa . SA_BrlShowTextW ( text ) def sa_output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Outputs text using System Access. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\" self . sa_say ( text , interrupt = interrupt ) self . sa_braille ( text ) def sa_running ( self ) -> bool : \"\"\" Determines if System Access is running. Returns: True if System Access is running, False otherwise. \"\"\" status : bool = False if self . _sa is not None : status = bool ( self . _sa . SA_IsRunning ()) return status def sa_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using System Access. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . _sa is not None : if interrupt : self . sa_silence () self . _sa . SA_SayW ( text ) def sa_silence ( self ) -> None : \"\"\"Cancels System Access speech and flushes the speech buffer.\"\"\" if self . _sa is not None : self . _sa . SA_StopAudio () def sapi_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using SAPI. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . sapi is not None : if interrupt : self . sapi . Speak ( text , SPF_ASYNC | SPF_PURGE_BEFORE_SPEAK | SPF_IS_NOT_XML ) else : self . sapi . Speak ( text , SPF_ASYNC | SPF_IS_NOT_XML ) def sapi_silence ( self ) -> None : \"\"\"Cancels SAPI speech and flushes the speech buffer.\"\"\" if self . sapi is not None : self . sapi . Speak ( \"\" , SPF_ASYNC | SPF_PURGE_BEFORE_SPEAK | SPF_IS_NOT_XML ) def braille ( self , text : str ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_braille ( text ) elif self . sa_running (): self . sa_braille ( text ) elif self . jfw_running (): self . jfw_braille ( text ) def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_output ( text , interrupt = interrupt ) elif self . sa_running (): self . sa_output ( text , interrupt = interrupt ) elif self . jfw_running (): self . jfw_output ( text , braille = True , speak = True , interrupt = interrupt ) else : self . sapi_say ( text , interrupt = interrupt ) def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_say ( text , interrupt = interrupt ) elif self . sa_running (): self . sa_say ( text , interrupt = interrupt ) elif self . jfw_running (): self . jfw_say ( text , interrupt = interrupt ) else : self . sapi_say ( text , interrupt = interrupt ) def silence ( self ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_silence () elif self . sa_running (): self . sa_silence () elif self . jfw_running (): self . jfw_silence () else : self . sapi_silence () def speaking ( self ) -> bool : # NOQA: D102 if self . nvda_running () or self . sa_running () or self . jfw_running (): # None of the screen reader APIs support retrieving speaking status. return False if self . sapi is not None : return bool ( self . sapi . Status . RunningState != 1 ) return False Attribute jfw : Any property readonly \u00b6 The JFW COM object. Attribute sapi : Any property readonly \u00b6 The SAPI COM object. Method __init__ ( self ) special \u00b6 Defines the constructor. Source code in speechlight/windows.py def __init__ ( self ) -> None : # pragma: no cover \"\"\"Defines the constructor.\"\"\" if sys . platform == \"win32\" : self . _find_window : ctypes . _NamedFuncPointer = ctypes . WinDLL ( \"user32\" ) . FindWindowW self . _find_window . argtypes = [ ctypes . c_wchar_p , ctypes . c_wchar_p ] self . _find_window . restype = ctypes . c_void_p arch : str = \"32\" if SYSTEM_ARCHITECTURE == \"32bit\" else \"64\" self . _nvda : ctypes . WinDLL = ctypes . windll . LoadLibrary ( str ( LIB_DIRECTORY / f \"nvdaControllerClient { arch } .dll\" ) ) self . _sa : ctypes . WinDLL = ctypes . windll . LoadLibrary ( str ( LIB_DIRECTORY / f \"SAAPI { arch } .dll\" )) self . _nvda . nvdaController_brailleMessage . argtypes = ( ctypes . c_wchar_p ,) self . _nvda . nvdaController_speakText . argtypes = ( ctypes . c_wchar_p ,) self . _sa . SA_BrlShowTextW . argtypes = ( ctypes . c_wchar_p ,) self . _sa . SA_SayW . argtypes = ( ctypes . c_wchar_p ,) Method braille ( self , text ) \u00b6 Brailles text. Parameters: Name Type Description Default text str The text to be brailled. required Source code in speechlight/windows.py def braille ( self , text : str ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_braille ( text ) elif self . sa_running (): self . sa_braille ( text ) elif self . jfw_running (): self . jfw_braille ( text ) Method jfw_braille ( self , text ) \u00b6 Brailles text using JFW. Parameters: Name Type Description Default text str The text to braille. required Source code in speechlight/windows.py def jfw_braille ( self , text : str ) -> None : \"\"\" Brailles text using JFW. Args: text: The text to braille. \"\"\" self . jfw_output ( text , braille = True ) Method jfw_output ( self , text , * , braille = False , speak = False , interrupt = False ) \u00b6 Outputs text using JFW. Parameters: Name Type Description Default text str The output text. required braille bool Output text in braille. False speak bool Output text using speech. False interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def jfw_output ( self , text : str , * , braille : bool = False , speak : bool = False , interrupt : bool = False , ) -> None : \"\"\" Outputs text using JFW. Args: text: The output text. braille: Output text in braille. speak: Output text using speech. interrupt: True if the speech should be silenced before speaking. \"\"\" jfw = self . jfw if jfw is not None : if speak : jfw . SayString ( text , int ( bool ( interrupt ))) if braille : jfw . RunFunction ( 'BrailleString(\" {text} \")' . format ( text = text . replace ( '\"' , \"'\" ))) Method jfw_running ( self ) \u00b6 Determines if JFW is running. Returns: Type Description bool True if JFW is running, False otherwise. Source code in speechlight/windows.py def jfw_running ( self ) -> bool : \"\"\" Determines if JFW is running. Returns: True if JFW is running, False otherwise. \"\"\" status : bool = False if self . _find_window is not None : status = bool ( self . _find_window ( \"JFWUI2\" , None )) return status Method jfw_say ( self , text , * , interrupt = False ) \u00b6 Speak text using JFW. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def jfw_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using JFW. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" self . jfw_output ( text , speak = True , interrupt = interrupt ) Method jfw_silence ( self ) \u00b6 Cancels JFW speech and flushes the speech buffer. Source code in speechlight/windows.py def jfw_silence ( self ) -> None : \"\"\"Cancels JFW speech and flushes the speech buffer.\"\"\" jfw = self . jfw if jfw is not None : jfw . StopSpeech () Method nvda_braille ( self , text ) \u00b6 Brailles text using NVDA. Parameters: Name Type Description Default text str The text to braille. required Source code in speechlight/windows.py def nvda_braille ( self , text : str ) -> None : \"\"\" Brailles text using NVDA. Args: text: The text to braille. \"\"\" if self . _nvda is not None : self . _nvda . nvdaController_brailleMessage ( text ) Method nvda_output ( self , text , * , interrupt = False ) \u00b6 Outputs text using NVDA. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def nvda_output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Outputs text using NVDA. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\" self . nvda_say ( text , interrupt = interrupt ) self . nvda_braille ( text ) Method nvda_running ( self ) \u00b6 Determines if NVDA is running. Returns: Type Description bool True if NVDA is running, False otherwise. Source code in speechlight/windows.py def nvda_running ( self ) -> bool : \"\"\" Determines if NVDA is running. Returns: True if NVDA is running, False otherwise. \"\"\" status : bool = False if self . _nvda is not None : status = bool ( self . _nvda . nvdaController_testIfRunning () == 0 ) return status Method nvda_say ( self , text , * , interrupt = False ) \u00b6 Speak text using NVDA. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def nvda_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using NVDA. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . _nvda is not None : if interrupt : self . nvda_silence () self . _nvda . nvdaController_speakText ( text ) Method nvda_silence ( self ) \u00b6 Cancels NVDA speech and flushes the speech buffer. Source code in speechlight/windows.py def nvda_silence ( self ) -> None : \"\"\"Cancels NVDA speech and flushes the speech buffer.\"\"\" if self . _nvda is not None : self . _nvda . nvdaController_cancelSpeech () Method output ( self , text , * , interrupt = False ) \u00b6 Speaks and brailles text. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_output ( text , interrupt = interrupt ) elif self . sa_running (): self . sa_output ( text , interrupt = interrupt ) elif self . jfw_running (): self . jfw_output ( text , braille = True , speak = True , interrupt = interrupt ) else : self . sapi_say ( text , interrupt = interrupt ) Method sa_braille ( self , text ) \u00b6 Brailles text using System Access. Parameters: Name Type Description Default text str The text to braille. required Source code in speechlight/windows.py def sa_braille ( self , text : str ) -> None : \"\"\" Brailles text using System Access. Args: text: The text to braille. \"\"\" if self . _sa is not None : self . _sa . SA_BrlShowTextW ( text ) Method sa_output ( self , text , * , interrupt = False ) \u00b6 Outputs text using System Access. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def sa_output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Outputs text using System Access. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\" self . sa_say ( text , interrupt = interrupt ) self . sa_braille ( text ) Method sa_running ( self ) \u00b6 Determines if System Access is running. Returns: Type Description bool True if System Access is running, False otherwise. Source code in speechlight/windows.py def sa_running ( self ) -> bool : \"\"\" Determines if System Access is running. Returns: True if System Access is running, False otherwise. \"\"\" status : bool = False if self . _sa is not None : status = bool ( self . _sa . SA_IsRunning ()) return status Method sa_say ( self , text , * , interrupt = False ) \u00b6 Speak text using System Access. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def sa_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using System Access. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . _sa is not None : if interrupt : self . sa_silence () self . _sa . SA_SayW ( text ) Method sa_silence ( self ) \u00b6 Cancels System Access speech and flushes the speech buffer. Source code in speechlight/windows.py def sa_silence ( self ) -> None : \"\"\"Cancels System Access speech and flushes the speech buffer.\"\"\" if self . _sa is not None : self . _sa . SA_StopAudio () Method sapi_say ( self , text , * , interrupt = False ) \u00b6 Speak text using SAPI. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def sapi_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using SAPI. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . sapi is not None : if interrupt : self . sapi . Speak ( text , SPF_ASYNC | SPF_PURGE_BEFORE_SPEAK | SPF_IS_NOT_XML ) else : self . sapi . Speak ( text , SPF_ASYNC | SPF_IS_NOT_XML ) Method sapi_silence ( self ) \u00b6 Cancels SAPI speech and flushes the speech buffer. Source code in speechlight/windows.py def sapi_silence ( self ) -> None : \"\"\"Cancels SAPI speech and flushes the speech buffer.\"\"\" if self . sapi is not None : self . sapi . Speak ( \"\" , SPF_ASYNC | SPF_PURGE_BEFORE_SPEAK | SPF_IS_NOT_XML ) Method say ( self , text , * , interrupt = False ) \u00b6 Speaks text. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_say ( text , interrupt = interrupt ) elif self . sa_running (): self . sa_say ( text , interrupt = interrupt ) elif self . jfw_running (): self . jfw_say ( text , interrupt = interrupt ) else : self . sapi_say ( text , interrupt = interrupt ) Method silence ( self ) \u00b6 Cancels speech and flushes the speech buffer. Source code in speechlight/windows.py def silence ( self ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_silence () elif self . sa_running (): self . sa_silence () elif self . jfw_running (): self . jfw_silence () else : self . sapi_silence () Method speaking ( self ) \u00b6 Determines if text is currently being spoken. Returns: Type Description bool True if text is currently being spoken, False otherwise. Source code in speechlight/windows.py def speaking ( self ) -> bool : # NOQA: D102 if self . nvda_running () or self . sa_running () or self . jfw_running (): # None of the screen reader APIs support retrieving speaking status. return False if self . sapi is not None : return bool ( self . sapi . Status . RunningState != 1 ) return False Function dispatch ( * args , ** kwargs ) \u00b6 Calls win32com.client.Dispatch with the supplied arguments. If the call fails, then an attempt is made to clear the cache and try again. Note https://stackoverflow.com/questions/33267002/why-am-i-suddenly-getting-a-no-attribute-clsidtopackagemap-error-with-win32com Parameters: Name Type Description Default *args Any Positional arguments to be passed to win32com.client.Dispatch. () **kwargs Any Key-word only arguments to be passed to win32com.client.Dispatch. {} Returns: Type Description Any The resulting COM reference. Source code in speechlight/windows.py def dispatch ( * args : Any , ** kwargs : Any ) -> Any : # pragma: no cover \"\"\" Calls win32com.client.Dispatch with the supplied arguments. If the call fails, then an attempt is made to clear the cache and try again. Note: https://stackoverflow.com/questions/33267002/why-am-i-suddenly-getting-a-no-attribute-clsidtopackagemap-error-with-win32com Args: *args: Positional arguments to be passed to win32com.client.Dispatch. **kwargs: Key-word only arguments to be passed to win32com.client.Dispatch. Returns: The resulting COM reference. \"\"\" app = None if sys . platform == \"win32\" : try : from win32com import client # NOQA: PLC0415 app = client . Dispatch ( * args , ** kwargs ) except AttributeError : # Remove cache and try again. from win32com.client import gencache # NOQA: PLC0415 if not hasattr ( gencache , \"GetGeneratePath\" ): return None cache_location = gencache . GetGeneratePath () del gencache modules = [ m . __name__ for m in sys . modules . values ()] for module in modules : if re . match ( r \"win32com\\.(?:gen_py|client)\\..+\" , module ): del sys . modules [ module ] if \"gen_py\" in cache_location : shutil . rmtree ( cache_location , ignore_errors = True ) from win32com import client # NOQA: PLC0415 app = client . Dispatch ( * args , ** kwargs ) except ComError : return None del client return app","title":"windows.py"},{"location":"api/windows/#speechlight.windows","text":"Windows speech.","title":"windows"},{"location":"api/windows/#speechlight.windows.Speech","text":"Implements Speech for Windows. Source code in speechlight/windows.py class Speech ( BaseSpeech ): # NOQA: PLR0904 \"\"\"Implements Speech for Windows.\"\"\" _find_window : Optional [ Any ] = None _nvda : Optional [ Any ] = None _sa : Optional [ Any ] = None _sapi : Optional [ Any ] = None _jfw : Optional [ Any ] = None def __init__ ( self ) -> None : # pragma: no cover \"\"\"Defines the constructor.\"\"\" if sys . platform == \"win32\" : self . _find_window : ctypes . _NamedFuncPointer = ctypes . WinDLL ( \"user32\" ) . FindWindowW self . _find_window . argtypes = [ ctypes . c_wchar_p , ctypes . c_wchar_p ] self . _find_window . restype = ctypes . c_void_p arch : str = \"32\" if SYSTEM_ARCHITECTURE == \"32bit\" else \"64\" self . _nvda : ctypes . WinDLL = ctypes . windll . LoadLibrary ( str ( LIB_DIRECTORY / f \"nvdaControllerClient { arch } .dll\" ) ) self . _sa : ctypes . WinDLL = ctypes . windll . LoadLibrary ( str ( LIB_DIRECTORY / f \"SAAPI { arch } .dll\" )) self . _nvda . nvdaController_brailleMessage . argtypes = ( ctypes . c_wchar_p ,) self . _nvda . nvdaController_speakText . argtypes = ( ctypes . c_wchar_p ,) self . _sa . SA_BrlShowTextW . argtypes = ( ctypes . c_wchar_p ,) self . _sa . SA_SayW . argtypes = ( ctypes . c_wchar_p ,) @property def sapi ( self ) -> Any : # type: ignore[misc] # pragma: no cover \"\"\"The SAPI COM object.\"\"\" self . _sapi = dispatch ( \"SAPI.SpVoice\" ) return self . _sapi @property def jfw ( self ) -> Any : # type: ignore[misc] # pragma: no cover \"\"\"The JFW COM object.\"\"\" self . _jfw = dispatch ( \"FreedomSci.JawsApi\" ) return self . _jfw def jfw_braille ( self , text : str ) -> None : \"\"\" Brailles text using JFW. Args: text: The text to braille. \"\"\" self . jfw_output ( text , braille = True ) def jfw_output ( self , text : str , * , braille : bool = False , speak : bool = False , interrupt : bool = False , ) -> None : \"\"\" Outputs text using JFW. Args: text: The output text. braille: Output text in braille. speak: Output text using speech. interrupt: True if the speech should be silenced before speaking. \"\"\" jfw = self . jfw if jfw is not None : if speak : jfw . SayString ( text , int ( bool ( interrupt ))) if braille : jfw . RunFunction ( 'BrailleString(\" {text} \")' . format ( text = text . replace ( '\"' , \"'\" ))) def jfw_running ( self ) -> bool : \"\"\" Determines if JFW is running. Returns: True if JFW is running, False otherwise. \"\"\" status : bool = False if self . _find_window is not None : status = bool ( self . _find_window ( \"JFWUI2\" , None )) return status def jfw_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using JFW. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" self . jfw_output ( text , speak = True , interrupt = interrupt ) def jfw_silence ( self ) -> None : \"\"\"Cancels JFW speech and flushes the speech buffer.\"\"\" jfw = self . jfw if jfw is not None : jfw . StopSpeech () def nvda_braille ( self , text : str ) -> None : \"\"\" Brailles text using NVDA. Args: text: The text to braille. \"\"\" if self . _nvda is not None : self . _nvda . nvdaController_brailleMessage ( text ) def nvda_output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Outputs text using NVDA. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\" self . nvda_say ( text , interrupt = interrupt ) self . nvda_braille ( text ) def nvda_running ( self ) -> bool : \"\"\" Determines if NVDA is running. Returns: True if NVDA is running, False otherwise. \"\"\" status : bool = False if self . _nvda is not None : status = bool ( self . _nvda . nvdaController_testIfRunning () == 0 ) return status def nvda_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using NVDA. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . _nvda is not None : if interrupt : self . nvda_silence () self . _nvda . nvdaController_speakText ( text ) def nvda_silence ( self ) -> None : \"\"\"Cancels NVDA speech and flushes the speech buffer.\"\"\" if self . _nvda is not None : self . _nvda . nvdaController_cancelSpeech () def sa_braille ( self , text : str ) -> None : \"\"\" Brailles text using System Access. Args: text: The text to braille. \"\"\" if self . _sa is not None : self . _sa . SA_BrlShowTextW ( text ) def sa_output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Outputs text using System Access. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\" self . sa_say ( text , interrupt = interrupt ) self . sa_braille ( text ) def sa_running ( self ) -> bool : \"\"\" Determines if System Access is running. Returns: True if System Access is running, False otherwise. \"\"\" status : bool = False if self . _sa is not None : status = bool ( self . _sa . SA_IsRunning ()) return status def sa_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using System Access. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . _sa is not None : if interrupt : self . sa_silence () self . _sa . SA_SayW ( text ) def sa_silence ( self ) -> None : \"\"\"Cancels System Access speech and flushes the speech buffer.\"\"\" if self . _sa is not None : self . _sa . SA_StopAudio () def sapi_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using SAPI. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . sapi is not None : if interrupt : self . sapi . Speak ( text , SPF_ASYNC | SPF_PURGE_BEFORE_SPEAK | SPF_IS_NOT_XML ) else : self . sapi . Speak ( text , SPF_ASYNC | SPF_IS_NOT_XML ) def sapi_silence ( self ) -> None : \"\"\"Cancels SAPI speech and flushes the speech buffer.\"\"\" if self . sapi is not None : self . sapi . Speak ( \"\" , SPF_ASYNC | SPF_PURGE_BEFORE_SPEAK | SPF_IS_NOT_XML ) def braille ( self , text : str ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_braille ( text ) elif self . sa_running (): self . sa_braille ( text ) elif self . jfw_running (): self . jfw_braille ( text ) def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_output ( text , interrupt = interrupt ) elif self . sa_running (): self . sa_output ( text , interrupt = interrupt ) elif self . jfw_running (): self . jfw_output ( text , braille = True , speak = True , interrupt = interrupt ) else : self . sapi_say ( text , interrupt = interrupt ) def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_say ( text , interrupt = interrupt ) elif self . sa_running (): self . sa_say ( text , interrupt = interrupt ) elif self . jfw_running (): self . jfw_say ( text , interrupt = interrupt ) else : self . sapi_say ( text , interrupt = interrupt ) def silence ( self ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_silence () elif self . sa_running (): self . sa_silence () elif self . jfw_running (): self . jfw_silence () else : self . sapi_silence () def speaking ( self ) -> bool : # NOQA: D102 if self . nvda_running () or self . sa_running () or self . jfw_running (): # None of the screen reader APIs support retrieving speaking status. return False if self . sapi is not None : return bool ( self . sapi . Status . RunningState != 1 ) return False","title":"Speech"},{"location":"api/windows/#speechlight.windows.Speech.jfw","text":"The JFW COM object.","title":"jfw"},{"location":"api/windows/#speechlight.windows.Speech.sapi","text":"The SAPI COM object.","title":"sapi"},{"location":"api/windows/#speechlight.windows.Speech.__init__","text":"Defines the constructor. Source code in speechlight/windows.py def __init__ ( self ) -> None : # pragma: no cover \"\"\"Defines the constructor.\"\"\" if sys . platform == \"win32\" : self . _find_window : ctypes . _NamedFuncPointer = ctypes . WinDLL ( \"user32\" ) . FindWindowW self . _find_window . argtypes = [ ctypes . c_wchar_p , ctypes . c_wchar_p ] self . _find_window . restype = ctypes . c_void_p arch : str = \"32\" if SYSTEM_ARCHITECTURE == \"32bit\" else \"64\" self . _nvda : ctypes . WinDLL = ctypes . windll . LoadLibrary ( str ( LIB_DIRECTORY / f \"nvdaControllerClient { arch } .dll\" ) ) self . _sa : ctypes . WinDLL = ctypes . windll . LoadLibrary ( str ( LIB_DIRECTORY / f \"SAAPI { arch } .dll\" )) self . _nvda . nvdaController_brailleMessage . argtypes = ( ctypes . c_wchar_p ,) self . _nvda . nvdaController_speakText . argtypes = ( ctypes . c_wchar_p ,) self . _sa . SA_BrlShowTextW . argtypes = ( ctypes . c_wchar_p ,) self . _sa . SA_SayW . argtypes = ( ctypes . c_wchar_p ,)","title":"__init__()"},{"location":"api/windows/#speechlight.windows.Speech.braille","text":"Brailles text. Parameters: Name Type Description Default text str The text to be brailled. required Source code in speechlight/windows.py def braille ( self , text : str ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_braille ( text ) elif self . sa_running (): self . sa_braille ( text ) elif self . jfw_running (): self . jfw_braille ( text )","title":"braille()"},{"location":"api/windows/#speechlight.windows.Speech.jfw_braille","text":"Brailles text using JFW. Parameters: Name Type Description Default text str The text to braille. required Source code in speechlight/windows.py def jfw_braille ( self , text : str ) -> None : \"\"\" Brailles text using JFW. Args: text: The text to braille. \"\"\" self . jfw_output ( text , braille = True )","title":"jfw_braille()"},{"location":"api/windows/#speechlight.windows.Speech.jfw_output","text":"Outputs text using JFW. Parameters: Name Type Description Default text str The output text. required braille bool Output text in braille. False speak bool Output text using speech. False interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def jfw_output ( self , text : str , * , braille : bool = False , speak : bool = False , interrupt : bool = False , ) -> None : \"\"\" Outputs text using JFW. Args: text: The output text. braille: Output text in braille. speak: Output text using speech. interrupt: True if the speech should be silenced before speaking. \"\"\" jfw = self . jfw if jfw is not None : if speak : jfw . SayString ( text , int ( bool ( interrupt ))) if braille : jfw . RunFunction ( 'BrailleString(\" {text} \")' . format ( text = text . replace ( '\"' , \"'\" )))","title":"jfw_output()"},{"location":"api/windows/#speechlight.windows.Speech.jfw_running","text":"Determines if JFW is running. Returns: Type Description bool True if JFW is running, False otherwise. Source code in speechlight/windows.py def jfw_running ( self ) -> bool : \"\"\" Determines if JFW is running. Returns: True if JFW is running, False otherwise. \"\"\" status : bool = False if self . _find_window is not None : status = bool ( self . _find_window ( \"JFWUI2\" , None )) return status","title":"jfw_running()"},{"location":"api/windows/#speechlight.windows.Speech.jfw_say","text":"Speak text using JFW. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def jfw_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using JFW. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" self . jfw_output ( text , speak = True , interrupt = interrupt )","title":"jfw_say()"},{"location":"api/windows/#speechlight.windows.Speech.jfw_silence","text":"Cancels JFW speech and flushes the speech buffer. Source code in speechlight/windows.py def jfw_silence ( self ) -> None : \"\"\"Cancels JFW speech and flushes the speech buffer.\"\"\" jfw = self . jfw if jfw is not None : jfw . StopSpeech ()","title":"jfw_silence()"},{"location":"api/windows/#speechlight.windows.Speech.nvda_braille","text":"Brailles text using NVDA. Parameters: Name Type Description Default text str The text to braille. required Source code in speechlight/windows.py def nvda_braille ( self , text : str ) -> None : \"\"\" Brailles text using NVDA. Args: text: The text to braille. \"\"\" if self . _nvda is not None : self . _nvda . nvdaController_brailleMessage ( text )","title":"nvda_braille()"},{"location":"api/windows/#speechlight.windows.Speech.nvda_output","text":"Outputs text using NVDA. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def nvda_output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Outputs text using NVDA. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\" self . nvda_say ( text , interrupt = interrupt ) self . nvda_braille ( text )","title":"nvda_output()"},{"location":"api/windows/#speechlight.windows.Speech.nvda_running","text":"Determines if NVDA is running. Returns: Type Description bool True if NVDA is running, False otherwise. Source code in speechlight/windows.py def nvda_running ( self ) -> bool : \"\"\" Determines if NVDA is running. Returns: True if NVDA is running, False otherwise. \"\"\" status : bool = False if self . _nvda is not None : status = bool ( self . _nvda . nvdaController_testIfRunning () == 0 ) return status","title":"nvda_running()"},{"location":"api/windows/#speechlight.windows.Speech.nvda_say","text":"Speak text using NVDA. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def nvda_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using NVDA. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . _nvda is not None : if interrupt : self . nvda_silence () self . _nvda . nvdaController_speakText ( text )","title":"nvda_say()"},{"location":"api/windows/#speechlight.windows.Speech.nvda_silence","text":"Cancels NVDA speech and flushes the speech buffer. Source code in speechlight/windows.py def nvda_silence ( self ) -> None : \"\"\"Cancels NVDA speech and flushes the speech buffer.\"\"\" if self . _nvda is not None : self . _nvda . nvdaController_cancelSpeech ()","title":"nvda_silence()"},{"location":"api/windows/#speechlight.windows.Speech.output","text":"Speaks and brailles text. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def output ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_output ( text , interrupt = interrupt ) elif self . sa_running (): self . sa_output ( text , interrupt = interrupt ) elif self . jfw_running (): self . jfw_output ( text , braille = True , speak = True , interrupt = interrupt ) else : self . sapi_say ( text , interrupt = interrupt )","title":"output()"},{"location":"api/windows/#speechlight.windows.Speech.sa_braille","text":"Brailles text using System Access. Parameters: Name Type Description Default text str The text to braille. required Source code in speechlight/windows.py def sa_braille ( self , text : str ) -> None : \"\"\" Brailles text using System Access. Args: text: The text to braille. \"\"\" if self . _sa is not None : self . _sa . SA_BrlShowTextW ( text )","title":"sa_braille()"},{"location":"api/windows/#speechlight.windows.Speech.sa_output","text":"Outputs text using System Access. Parameters: Name Type Description Default text str The output text. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def sa_output ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Outputs text using System Access. Args: text: The output text. interrupt: True if the speech should be silenced before speaking. \"\"\" self . sa_say ( text , interrupt = interrupt ) self . sa_braille ( text )","title":"sa_output()"},{"location":"api/windows/#speechlight.windows.Speech.sa_running","text":"Determines if System Access is running. Returns: Type Description bool True if System Access is running, False otherwise. Source code in speechlight/windows.py def sa_running ( self ) -> bool : \"\"\" Determines if System Access is running. Returns: True if System Access is running, False otherwise. \"\"\" status : bool = False if self . _sa is not None : status = bool ( self . _sa . SA_IsRunning ()) return status","title":"sa_running()"},{"location":"api/windows/#speechlight.windows.Speech.sa_say","text":"Speak text using System Access. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def sa_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using System Access. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . _sa is not None : if interrupt : self . sa_silence () self . _sa . SA_SayW ( text )","title":"sa_say()"},{"location":"api/windows/#speechlight.windows.Speech.sa_silence","text":"Cancels System Access speech and flushes the speech buffer. Source code in speechlight/windows.py def sa_silence ( self ) -> None : \"\"\"Cancels System Access speech and flushes the speech buffer.\"\"\" if self . _sa is not None : self . _sa . SA_StopAudio ()","title":"sa_silence()"},{"location":"api/windows/#speechlight.windows.Speech.sapi_say","text":"Speak text using SAPI. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def sapi_say ( self , text : str , * , interrupt : bool = False ) -> None : \"\"\" Speak text using SAPI. Args: text: The text to be spoken. interrupt: True if the speech should be silenced before speaking. \"\"\" if self . sapi is not None : if interrupt : self . sapi . Speak ( text , SPF_ASYNC | SPF_PURGE_BEFORE_SPEAK | SPF_IS_NOT_XML ) else : self . sapi . Speak ( text , SPF_ASYNC | SPF_IS_NOT_XML )","title":"sapi_say()"},{"location":"api/windows/#speechlight.windows.Speech.sapi_silence","text":"Cancels SAPI speech and flushes the speech buffer. Source code in speechlight/windows.py def sapi_silence ( self ) -> None : \"\"\"Cancels SAPI speech and flushes the speech buffer.\"\"\" if self . sapi is not None : self . sapi . Speak ( \"\" , SPF_ASYNC | SPF_PURGE_BEFORE_SPEAK | SPF_IS_NOT_XML )","title":"sapi_silence()"},{"location":"api/windows/#speechlight.windows.Speech.say","text":"Speaks text. Parameters: Name Type Description Default text str The text to be spoken. required interrupt bool True if the speech should be silenced before speaking. False Source code in speechlight/windows.py def say ( self , text : str , * , interrupt : bool = False ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_say ( text , interrupt = interrupt ) elif self . sa_running (): self . sa_say ( text , interrupt = interrupt ) elif self . jfw_running (): self . jfw_say ( text , interrupt = interrupt ) else : self . sapi_say ( text , interrupt = interrupt )","title":"say()"},{"location":"api/windows/#speechlight.windows.Speech.silence","text":"Cancels speech and flushes the speech buffer. Source code in speechlight/windows.py def silence ( self ) -> None : # NOQA: D102 if self . nvda_running (): self . nvda_silence () elif self . sa_running (): self . sa_silence () elif self . jfw_running (): self . jfw_silence () else : self . sapi_silence ()","title":"silence()"},{"location":"api/windows/#speechlight.windows.Speech.speaking","text":"Determines if text is currently being spoken. Returns: Type Description bool True if text is currently being spoken, False otherwise. Source code in speechlight/windows.py def speaking ( self ) -> bool : # NOQA: D102 if self . nvda_running () or self . sa_running () or self . jfw_running (): # None of the screen reader APIs support retrieving speaking status. return False if self . sapi is not None : return bool ( self . sapi . Status . RunningState != 1 ) return False","title":"speaking()"},{"location":"api/windows/#speechlight.windows.dispatch","text":"Calls win32com.client.Dispatch with the supplied arguments. If the call fails, then an attempt is made to clear the cache and try again. Note https://stackoverflow.com/questions/33267002/why-am-i-suddenly-getting-a-no-attribute-clsidtopackagemap-error-with-win32com Parameters: Name Type Description Default *args Any Positional arguments to be passed to win32com.client.Dispatch. () **kwargs Any Key-word only arguments to be passed to win32com.client.Dispatch. {} Returns: Type Description Any The resulting COM reference. Source code in speechlight/windows.py def dispatch ( * args : Any , ** kwargs : Any ) -> Any : # pragma: no cover \"\"\" Calls win32com.client.Dispatch with the supplied arguments. If the call fails, then an attempt is made to clear the cache and try again. Note: https://stackoverflow.com/questions/33267002/why-am-i-suddenly-getting-a-no-attribute-clsidtopackagemap-error-with-win32com Args: *args: Positional arguments to be passed to win32com.client.Dispatch. **kwargs: Key-word only arguments to be passed to win32com.client.Dispatch. Returns: The resulting COM reference. \"\"\" app = None if sys . platform == \"win32\" : try : from win32com import client # NOQA: PLC0415 app = client . Dispatch ( * args , ** kwargs ) except AttributeError : # Remove cache and try again. from win32com.client import gencache # NOQA: PLC0415 if not hasattr ( gencache , \"GetGeneratePath\" ): return None cache_location = gencache . GetGeneratePath () del gencache modules = [ m . __name__ for m in sys . modules . values ()] for module in modules : if re . match ( r \"win32com\\.(?:gen_py|client)\\..+\" , module ): del sys . modules [ module ] if \"gen_py\" in cache_location : shutil . rmtree ( cache_location , ignore_errors = True ) from win32com import client # NOQA: PLC0415 app = client . Dispatch ( * args , ** kwargs ) except ComError : return None del client return app","title":"dispatch()"}]}